import{_ as t}from"./chunks/typeof.3c5da837.js";import{_ as e,o,c as a,a4 as i}from"./chunks/framework.c4ff8a6b.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/JavaScript/DataMonitoring/typeof.md","filePath":"Web/JavaScript/DataMonitoring/typeof.md","lastUpdated":1693864762000}'),l={name:"Web/JavaScript/DataMonitoring/typeof.md"},n=i('<h2 id="数据类型检测" tabindex="-1">数据类型检测 <a class="header-anchor" href="#数据类型检测" aria-label="Permalink to &quot;数据类型检测&quot;">​</a></h2><h3 id="typeof" tabindex="-1">typeof <a class="header-anchor" href="#typeof" aria-label="Permalink to &quot;typeof&quot;">​</a></h3><p>基于 <strong>typeof</strong>  检测出的结果</p><ol><li>首先是一个字符串</li><li>字符串中包含对于的类型</li></ol><p>局限性：</p><ol><li>typeof null = object 但是 null 并不是对象</li><li>基于 typeof 无法细分出当前值是普通对象还是数组对象，因为只要是对象数据类型，返回的都是&#39;object&#39;</li></ol><p><img src="'+t+'" alt="image.png"></p><p>有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：</p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回 function 类型。</li></ul><p>其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。</p>',10),p=[n];function r(c,s,_,f,d,u){return o(),a("div",null,p)}const b=e(l,[["render",r]]);export{y as __pageData,b as default};
