import{_ as s,o as a,c as n,a4 as e}from"./chunks/framework.c4ff8a6b.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/JavaScript/TepDead.md","filePath":"Web/JavaScript/TepDead.md","lastUpdated":1693864762000}'),l={name:"Web/JavaScript/TepDead.md"},p=e(`<h2 id="let-vs-var-及暂时性死区问题" tabindex="-1">let vs var 及暂时性死区问题 <a class="header-anchor" href="#let-vs-var-及暂时性死区问题" aria-label="Permalink to &quot;let vs var 及暂时性死区问题&quot;">​</a></h2><p><strong>let vs var</strong></p><ol><li>let 没有变量提升（但是在词法解析阶段也得知某个变量是否为私有变量</li><li>let 不允许在相同作用域下重复声明</li><li>let 解决了 js 中的暂时性死区问题</li><li>let 创建的全局变量每一天给 window 设置对应的属性</li><li>let 会产生块级作用域</li></ol><p><strong>暂时性死区问题</strong> <br>暂时性死区：<span style="color:blueviolet;">在 ES6 之前，使用 typeof 运算符操作一个未声明的变量的时候，不会报错，该变量以 undefined 处理，而在 ES6 之后，使用 ES6 的变量声明方法（let const claa,）不可以在声明前使用 typeof ，否则会显示报错，ES6 变量声明前的代码区域，被称为暂时性死区</span></p><p><strong>1.ES6 之前</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> a); </span><span style="color:#6A737D;">//undefined; （a并没有用var,function声明）但未报错</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> a); </span><span style="color:#6A737D;">//undefined; （a并没有用var,function声明）但未报错</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>2.ES6 之后</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 暂时性死区 start</span></span>
<span class="line"><span style="color:#E1E4E8;">consoloe.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> a); </span><span style="color:#6A737D;">//Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization</span></span>
<span class="line"><span style="color:#6A737D;">// 暂时性死区结束 end</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 暂时性死区 start</span></span>
<span class="line"><span style="color:#24292E;">consoloe.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> a); </span><span style="color:#6A737D;">//Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization</span></span>
<span class="line"><span style="color:#6A737D;">// 暂时性死区结束 end</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>`,8),o=[p];function t(r,c,i,d,y,v){return a(),n("div",null,o)}const b=s(l,[["render",t]]);export{u as __pageData,b as default};
