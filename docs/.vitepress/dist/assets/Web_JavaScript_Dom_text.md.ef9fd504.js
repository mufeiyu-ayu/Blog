import{_ as s,o as n,c as a,a4 as e}from"./chunks/framework.f8637b7f.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/JavaScript/Dom/text.md","filePath":"Web/JavaScript/Dom/text.md","lastUpdated":1693864762000}'),t={name:"Web/JavaScript/Dom/text.md"},l=e(`<h2 id="innerhtml-inertext-textcontent-的区别" tabindex="-1">innerHTML,inerText，textContent 的区别 <a class="header-anchor" href="#innerhtml-inertext-textcontent-的区别" aria-label="Permalink to &quot;innerHTML,inerText，textContent 的区别&quot;">​</a></h2><h3 id="_1-innerhtml" tabindex="-1">1.innerHTML <a class="header-anchor" href="#_1-innerhtml" aria-label="Permalink to &quot;1.innerHTML&quot;">​</a></h3><h4 id="_1-1-执行过程" tabindex="-1">1.1 执行过程 <a class="header-anchor" href="#_1-1-执行过程" aria-label="Permalink to &quot;1.1 执行过程&quot;">​</a></h4><p>当给 innerHTML 设置一个值的时候到底发生了什么？用户代理按照以下步骤：</p><ol><li>给定的值被解析为 HTML 或者 XML（取决于文档类型），结果就是 DocumentFragment 对象代表元素新设置的 DOM 节点。</li><li>如果元素内容被替换成 &lt;template&gt; 元素，&lt;template&gt; 元素的 content 属性会被替换为步骤 1 中创建的新的 DocumentFragment。</li><li>对于其他所有元素，元素的内容都被替换为新的 DocumentFragment 节点。</li></ol><h4 id="_1-2-安全问题" tabindex="-1">1.2 安全问题 <a class="header-anchor" href="#_1-2-安全问题" aria-label="Permalink to &quot;1.2 安全问题&quot;">​</a></h4><p><a href="https://so.csdn.net/so/search?q=HTML5&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">HTML5</a>和现代的新的浏览器都会阻止这种通过 innerHTML 嵌入 script 脚本的程序执行</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;John&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// assuming &#39;el&#39; is an HTML DOM element</span></span>
<span class="line"><span style="color:#E1E4E8;">el.innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> name; </span><span style="color:#6A737D;">// harmless in this case</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&lt;script&gt;alert(&#39;I am John in an annoying alert!&#39;)&lt;/script&gt;&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">el.innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> name; </span><span style="color:#6A737D;">// harmless in this case</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;John&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// assuming &#39;el&#39; is an HTML DOM element</span></span>
<span class="line"><span style="color:#24292E;">el.innerHTML </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name; </span><span style="color:#6A737D;">// harmless in this case</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&lt;script&gt;alert(&#39;I am John in an annoying alert!&#39;)&lt;/script&gt;&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">el.innerHTML </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name; </span><span style="color:#6A737D;">// harmless in this case</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>尽管这看上去像 <a href="https://zh.wikipedia.org/wiki/cross-site_scripting" target="_blank" rel="noreferrer">cross-site scripting</a> 攻击，结果并不会导致什么。HTML 5 中指定不执行由 innerHTML 插入的 &lt;script&gt;标签。<br>然而，有很多不依赖 &lt;script&gt; 标签去执行 JavaScript 的方式。所以当你使用 innerHTML 去设置你无法控制的字符串时，这仍然是一个安全问题。例如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&lt;img src=&#39;x&#39; onerror=&#39;alert(1)&#39;&gt;&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">el.innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> name; </span><span style="color:#6A737D;">// shows the alert</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&lt;img src=&#39;x&#39; onerror=&#39;alert(1)&#39;&gt;&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">el.innerHTML </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name; </span><span style="color:#6A737D;">// shows the alert</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>基于这个原因，当插入纯文本时，建议不要使用 innerHTML 。取而代之的是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent" target="_blank" rel="noreferrer">Node.textContent</a> ，它不会把给定的内容解析为 HTML，它仅仅是将原始文本插入给定的位置。</p><h4 id="_1-3-优化方案" tabindex="-1">1.3 优化方案 <a class="header-anchor" href="#_1-3-优化方案" aria-label="Permalink to &quot;1.3 优化方案&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">tr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;tr&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">tr.innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&lt;li&gt;11&lt;/li&gt;&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">ul.</span><span style="color:#B392F0;">appendchild</span><span style="color:#E1E4E8;">(tr);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">tr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;tr&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">tr.innerHTML </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&lt;li&gt;11&lt;/li&gt;&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">ul.</span><span style="color:#6F42C1;">appendchild</span><span style="color:#24292E;">(tr);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样就只是把一个字符串放进了一个 dom 节点里，这个节点是在<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">内存</a>里面的，并没有在 document 文档</p><h3 id="_2-textcontent" tabindex="-1">2.textContent <a class="header-anchor" href="#_2-textcontent" aria-label="Permalink to &quot;2.textContent&quot;">​</a></h3><h4 id="_2-1与-innertext-的区别" tabindex="-1">2.1<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent#%E4%B8%8E_innertext_%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">与 innerText 的区别</a> <a class="header-anchor" href="#_2-1与-innertext-的区别" aria-label="Permalink to &quot;2.1[与 innerText 的区别](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent#%E4%B8%8E_innertext_%E7%9A%84%E5%8C%BA%E5%88%AB)&quot;">​</a></h4><p>不要被 Node.textContent 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/innerText" target="_blank" rel="noreferrer">HTMLElement.innerText</a> 的区别搞混了。虽然名字看起来很相似，但有重要的不同之处：</p><ul><li>textContent 会获取<em>所有</em>元素的内容，包括 &lt;script&gt; 和 &lt;style&gt; 元素，然而 innerText 只展示给人看的元素。</li><li>textContent 会返回节点中的每一个元素。相反，innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本， <ul><li>此外，由于 innerText 受 CSS 样式的影响，它会触发回流（ <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow" target="_blank" rel="noreferrer">reflow</a> ）去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。）</li></ul></li><li>与 textContent 不同的是，在 Internet Explorer (小于和等于 11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会<em>永久性地破坏</em>所有后代文本节点。在之后不可能再次将节点再次插入到任何其他元素或同一元素中。</li><li>优点;当改写 textContent 时，只会将文本插入到元素内部去，性能比 innerHTML 好</li><li>它不会被解析成 dom 节点，只解析为文本节点（减少回流次数）</li></ul><h3 id="_3-innertext" tabindex="-1">3.innerText <a class="header-anchor" href="#_3-innertext" aria-label="Permalink to &quot;3.innerText&quot;">​</a></h3><p>给元素添加文本节点，只会获取给客户看的内容，script，以及 style 将会被隐藏</p><h3 id="_4-总结" tabindex="-1">4.总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4.总结&quot;">​</a></h3><p>innerHTML：性能不好，可以提取文本及 html 标签<br>innerText：性能好，只能提取文本，会剔除 html 标签及 script、style 内容，受 css 影响<br>textContent：性能好，可以提取文本及 script、style 内容，会剔除 html 标签，不受 css 影响</p>`,22),o=[l];function p(r,c,i,E,h,d){return n(),a("div",null,o)}const u=s(t,[["render",p]]);export{m as __pageData,u as default};
